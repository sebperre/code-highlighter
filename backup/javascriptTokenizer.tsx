import { Tokenizer } from "./Tokenizer";

export const javascriptTokenizer = new Tokenizer([
  // Keywords
  // { matcher: /\bconst\b/, type: "keyword", valueExtractor: (x) => x },
  // { matcher: /\byield\b/, type: "keyword", valueExtractor: (x) => x },

  { matcher: /[ \t]+/, type: "white-space", valueExtractor: (x) => x },
  { matcher: /\r?\n/, type: "line-break" },
  {
    matcher: /\/\/(.*?)(?=\r?\n|$)/,
    type: "comment",
    valueExtractor: (match) => match,
  },
  {
    matcher: /"[^"\r\n]+"/,
    type: "string-literal",
    valueExtractor: (match) => match,
  },
  {
    matcher: /'[^'\r\n]+'/,
    type: "string-literal",
    valueExtractor: (match) => match,
  },
  {
    matcher: /`[^`]+`/,
    type: "string-literal",
    valueExtractor: (match) => match,
  },
  {
    matcher: /-?[0-9]+\.?[0-9]*(?![a-zA-Z$_])/,
    type: "number-literal",
    valueExtractor: (match) => parseFloat(match),
  },
  // { matcher: /true/, type: "true", valueExtractor: (x) => x },
  // { matcher: /false/, type: "false", valueExtractor: (x) => x },

  // Restricted Symbols
  { matcher: /{/, type: "{" },
  { matcher: /}/, type: "}" },
  { matcher: /\[/, type: "[" },
  { matcher: /\]/, type: "]" },
  { matcher: /\(/, type: "(" },
  { matcher: /\)/, type: ")" },
  { matcher: /;/, type: ";" },
  { matcher: /:/, type: ":" },
  { matcher: /,/, type: "," },
  { matcher: /\.\.\./, type: "..." },
  { matcher: /\./, type: "." },
  { matcher: /\*\*/, type: "**" },
  { matcher: /\*/, type: "*" },
  { matcher: /===/, type: "===" },
  { matcher: /==/, type: "==" },
  { matcher: /=>/, type: "=>" },
  { matcher: /=/, type: "=" },
  { matcher: /!==/, type: "!==" },
  { matcher: /!=/, type: "!=" },
  { matcher: /&&/, type: "&&" },
  { matcher: /&/, type: "&" },
  { matcher: /\^/, type: "^" },
  { matcher: /~/, type: "~" },
  { matcher: /!/, type: "!" },
  { matcher: /\|\|/, type: "||" },
  { matcher: /\|/, type: "|" },
  { matcher: /\+\+/, type: "++" },
  { matcher: /\+/, type: "+" },
  { matcher: /\-\-/, type: "--" },
  { matcher: /\-/, type: "-" },
  { matcher: /\\/, type: "\\" },
  { matcher: /%/, type: "%" },
  { matcher: /\?\?/, type: "??" },
  { matcher: /\?/, type: "?" },
  { matcher: />=/, type: ">=" },
  { matcher: /<=/, type: "<=" },
  { matcher: />>/, type: ">>" },
  { matcher: />/, type: ">" },
  { matcher: /<</, type: "<<" },
  { matcher: /</, type: "<" },

  // { matcher: /\btrue\b/, type: "true" },
  // { matcher: /\bfalse\b/, type: "false" },
  // { matcher: /\babstract\b/, type: "abstract" },
  // { matcher: /\barguments\b/, type: "arguments" },
  // { matcher: /\bawait\b/, type: "await" },
  // { matcher: /\bboolean\b/, type: "boolean" },
  // { matcher: /\bbreak\b/, type: "break" },
  // { matcher: /\bbyte\b/, type: "byte" },
  // { matcher: /\bcase\b/, type: "case" },
  // { matcher: /\bcatch\b/, type: "catch" },
  // { matcher: /\bchar\b/, type: "char" },
  // { matcher: /\bclass\b/, type: "class" },
  // { matcher: /\bcontinue\b/, type: "continue" },
  // { matcher: /\bdebugger\b/, type: "debugger" },
  // { matcher: /\bdefault\b/, type: "default" },
  // { matcher: /\bdelete\b/, type: "delete" },
  // { matcher: /\bdo\b/, type: "do" },
  // { matcher: /\bdouble\b/, type: "double" },
  // { matcher: /\belse\b/, type: "else" },
  // { matcher: /\benum\b/, type: "enum" },
  // { matcher: /\beval\b/, type: "eval" },
  // { matcher: /\bexport\b/, type: "export" },
  // { matcher: /\bextends\b/, type: "extends" },
  // { matcher: /\bfinal\b/, type: "final" },
  // { matcher: /\bfinally\b/, type: "finally" },
  // { matcher: /\bfloat\b/, type: "float" },
  // { matcher: /\bfor\b/, type: "for" },
  // { matcher: /\bfunction\b/, type: "function" },
  // { matcher: /\bgoto\b/, type: "goto" },
  // { matcher: /\bif\b/, type: "if" },
  // { matcher: /\bimplements\b/, type: "implements" },
  // { matcher: /\bimport\b/, type: "import" },
  // { matcher: /\bin\b/, type: "in" },
  // { matcher: /\binstanceof\b/, type: "instanceof" },
  // { matcher: /\bint\b/, type: "int" },
  // { matcher: /\binterface\b/, type: "interface" },
  // { matcher: /\blet\b/, type: "let" },
  // { matcher: /\blong\b/, type: "long" },
  // { matcher: /\bnative\b/, type: "native" },
  // { matcher: /\bnew\b/, type: "new" },
  // { matcher: /\bnull\b/, type: "null" },
  // { matcher: /\bpackage\b/, type: "package" },
  // { matcher: /\bprivate\b/, type: "private" },
  // { matcher: /\bprotected\b/, type: "protected" },
  // { matcher: /\bpublic\b/, type: "public" },
  // { matcher: /\breturn\b/, type: "return" },
  // { matcher: /\bshort\b/, type: "short" },
  // { matcher: /\bstatic\b/, type: "static" },
  // { matcher: /\bsuper\b/, type: "super" },
  // { matcher: /\bswitch\b/, type: "switch" },
  // { matcher: /\bsynchronized\b/, type: "synchronized" },
  // { matcher: /\bthis\b/, type: "this" },
  // { matcher: /\bthrow\b/, type: "throw" },
  // { matcher: /\bthrows\b/, type: "throws" },
  // { matcher: /\btransient\b/, type: "transient" },
  // { matcher: /\btry\b/, type: "try" },
  // { matcher: /\btypeof\b/, type: "typeof" },
  // { matcher: /\bvar\b/, type: "var" },
  // { matcher: /\bvoid\b/, type: "void" },
  // { matcher: /\bvolatile\b/, type: "volatile" },
  // { matcher: /\bwhile\b/, type: "while" },
  // { matcher: /\bwith\b/, type: "with" },

  {
    matcher: /[a-zA-Z$_][a-zA-Z0-9$_]*/,
    type: "identifier",
    valueExtractor: (x) => x,
  },
]);
